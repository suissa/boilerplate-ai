# Regras do Projeto - Monorepo Nx (React + NestJS)

## ğŸ—ï¸ Arquitetura e Design Patterns

### SOLID Principles
- **S**ingle Responsibility: Cada classe/funÃ§Ã£o deve ter uma Ãºnica responsabilidade
- **O**pen/Closed: Aberto para extensÃ£o, fechado para modificaÃ§Ã£o
- **L**iskov Substitution: Subtipos devem ser substituÃ­veis por seus tipos base
- **I**nterface Segregation: Interfaces especÃ­ficas sÃ£o melhores que interfaces genÃ©ricas
- **D**ependency Inversion: Depender de abstraÃ§Ãµes, nÃ£o de implementaÃ§Ãµes concretas

### Clean Architecture
- **Entities**: Regras de negÃ³cio centrais (domÃ­nio)
- **Use Cases**: Casos de uso da aplicaÃ§Ã£o (aplicaÃ§Ã£o)
- **Interface Adapters**: Controllers, Presenters, Gateways (infraestrutura)
- **Frameworks & Drivers**: Frameworks, DB, UI (externo)

### Domain Driven Design (DDD)
- **Entities**: Objetos com identidade Ãºnica
- **Value Objects**: Objetos imutÃ¡veis sem identidade
- **Aggregates**: Clusters de entidades relacionadas
- **Repositories**: AbstraÃ§Ã£o para persistÃªncia
- **Services**: LÃ³gica de domÃ­nio que nÃ£o pertence a entidades
- **Events**: ComunicaÃ§Ã£o entre bounded contexts

## ğŸ” Fluxo de AutenticaÃ§Ã£o

### Cadastro de Novo UsuÃ¡rio
1. Cliente envia nome e email
2. Sistema gera cÃ³digo de login Ãºnico
3. Sistema envia cÃ³digo por email
4. Cliente digita cÃ³digo para ativar conta
5. Cliente Ã© logado automaticamente

### Login de UsuÃ¡rio Existente
1. Cliente clica em "Login"
2. Cliente digita email
3. Sistema gera novo cÃ³digo de login
4. Sistema envia cÃ³digo por email
5. Cliente digita cÃ³digo para logar
6. Cliente Ã© logado na plataforma

### SeguranÃ§a
- CÃ³digos de login expiram em 10 minutos
- MÃ¡ximo 3 tentativas por cÃ³digo
- Rate limiting: 3 tentativas por email por hora
- Logs de tentativas de login

## ğŸ“ Estrutura de Pastas

### Backend (NestJS)
```
apps/backend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ domain/           # Entidades, Value Objects, Interfaces
â”‚   â”‚   â”œâ”€â”€ entities/
â”‚   â”‚   â”œâ”€â”€ value-objects/
â”‚   â”‚   â”œâ”€â”€ repositories/
â”‚   â”‚   â””â”€â”€ services/
â”‚   â”œâ”€â”€ application/      # Use Cases, DTOs
â”‚   â”‚   â”œâ”€â”€ use-cases/
â”‚   â”‚   â”œâ”€â”€ dto/
â”‚   â”‚   â””â”€â”€ interfaces/
â”‚   â”œâ”€â”€ infrastructure/   # ImplementaÃ§Ãµes concretas
â”‚   â”‚   â”œâ”€â”€ database/
â”‚   â”‚   â”œâ”€â”€ external/
â”‚   â”‚   â””â”€â”€ config/
â”‚   â””â”€â”€ presentation/     # Controllers, Middlewares
â”‚       â”œâ”€â”€ controllers/
â”‚       â”œâ”€â”€ middlewares/
â”‚       â””â”€â”€ filters/
```

### Frontend (React)
```
apps/frontend/
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ domain/          # Entidades, Interfaces
â”‚   â”œâ”€â”€ application/     # Use Cases, Services
â”‚   â”œâ”€â”€ infrastructure/  # API, Storage
â”‚   â””â”€â”€ presentation/    # Components, Pages
```

## ğŸ”§ PadrÃµes de CÃ³digo

### Nomenclatura
- **Classes**: PascalCase (UserService, AuthController)
- **Interfaces**: PascalCase com prefixo I (IUserRepository)
- **FunÃ§Ãµes/MÃ©todos**: camelCase (createUser, validateEmail)
- **VariÃ¡veis**: camelCase (userData, isAuthenticated)
- **Constantes**: UPPER_SNAKE_CASE (MAX_LOGIN_ATTEMPTS)
- **Arquivos**: kebab-case (user-service.ts, auth-controller.ts)

### Estrutura de Classes
```typescript
// âœ… Bom exemplo
export class UserService {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly emailService: IEmailService
  ) {}

  async createUser(userData: CreateUserDto): Promise<User> {
    // ImplementaÃ§Ã£o
  }
}
```

### InjeÃ§Ã£o de DependÃªncia
- Sempre usar interfaces para dependÃªncias
- Injetar dependÃªncias via constructor
- Evitar new() dentro de classes de serviÃ§o

## ğŸŒ RESTful APIs

### PadrÃµes de Endpoints
- **POST** /auth/register - Cadastrar novo usuÃ¡rio
- **POST** /auth/login - Solicitar cÃ³digo de login
- **POST** /auth/verify-code - Verificar cÃ³digo de login
- **GET** /auth/me - Dados do usuÃ¡rio logado
- **POST** /auth/logout - Logout do usuÃ¡rio

### Respostas PadrÃ£o
```typescript
// âœ… Sucesso
{
  "success": true,
  "data": { ... },
  "message": "OperaÃ§Ã£o realizada com sucesso"
}

// âœ… Erro
{
  "success": false,
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Dados invÃ¡lidos",
    "details": [...]
  }
}
```

### Status Codes
- **200**: Sucesso
- **201**: Criado com sucesso
- **400**: Bad Request (validaÃ§Ã£o)
- **401**: Unauthorized
- **403**: Forbidden
- **404**: Not Found
- **422**: Unprocessable Entity
- **429**: Too Many Requests (rate limit)
- **500**: Internal Server Error

## ğŸ§ª Testes

### Estrutura de Testes
- **Unit Tests**: Testar lÃ³gica isolada
- **Integration Tests**: Testar integraÃ§Ã£o entre camadas
- **E2E Tests**: Testar fluxos completos

### PadrÃµes de Teste
```typescript
describe('UserService', () => {
  let service: UserService;
  let mockRepository: jest.Mocked<IUserRepository>;

  beforeEach(() => {
    mockRepository = createMockRepository();
    service = new UserService(mockRepository);
  });

  it('should create user successfully', async () => {
    // Arrange
    const userData = { email: 'test@example.com' };
    
    // Act
    const result = await service.createUser(userData);
    
    // Assert
    expect(result).toBeDefined();
    expect(mockRepository.save).toHaveBeenCalled();
  });
});
```

## ğŸ”’ SeguranÃ§a

### AutenticaÃ§Ã£o/AutorizaÃ§Ã£o
- CÃ³digos de login Ãºnicos e temporÃ¡rios
- Rate limiting por email/IP
- ValidaÃ§Ã£o de entrada
- SanitizaÃ§Ã£o de dados
- Logs de seguranÃ§a

### ValidaÃ§Ã£o
```typescript
// âœ… Usar class-validator
export class CreateUserDto {
  @IsEmail()
  @IsNotEmpty()
  email: string;

  @IsString()
  @MinLength(2)
  name: string;
}

export class LoginDto {
  @IsEmail()
  @IsNotEmpty()
  email: string;
}

export class VerifyCodeDto {
  @IsEmail()
  @IsNotEmpty()
  email: string;

  @IsString()
  @Length(6, 6)
  code: string;
}
```

## ğŸ“ DocumentaÃ§Ã£o

### ComentÃ¡rios
- Documentar interfaces pÃºblicas
- Explicar lÃ³gica complexa
- Usar JSDoc para mÃ©todos pÃºblicos

### README
- Setup do projeto
- Estrutura de pastas
- PadrÃµes de desenvolvimento
- Como contribuir

## ğŸš€ Performance

### Backend
- PaginaÃ§Ã£o em listagens
- Cache quando apropriado
- Lazy loading
- OtimizaÃ§Ã£o de queries

### Frontend
- Lazy loading de componentes
- MemoizaÃ§Ã£o (useMemo, useCallback)
- Code splitting
- OtimizaÃ§Ã£o de re-renders

## ğŸ”„ Versionamento

### Commits
- Usar Conventional Commits
- Exemplo: `feat(auth): add user registration endpoint`
- Tipos: feat, fix, docs, style, refactor, test, chore

### Branches
- `main`: CÃ³digo em produÃ§Ã£o
- `develop`: CÃ³digo em desenvolvimento
- `feature/`: Novas funcionalidades
- `fix/`: CorreÃ§Ãµes
- `hotfix/`: CorreÃ§Ãµes urgentes

## ğŸ“¦ DependÃªncias

### Backend
- NestJS (framework)
- TypeORM (ORM)
- class-validator (validaÃ§Ã£o)
- nodemailer (envio de emails)
- bcrypt (hash)
- rate-limiter-flexible (rate limiting)

### Frontend
- React (framework)
- Material-UI (UI)
- React Router (roteamento)
- Axios (HTTP client)
- React Query (cache)

## ğŸ¯ Regras Gerais

1. **Simplicidade**: CÃ³digo simples Ã© melhor que cÃ³digo complexo
2. **Legibilidade**: CÃ³digo deve ser auto-documentado
3. **Testabilidade**: CÃ³digo deve ser fÃ¡cil de testar
4. **Manutenibilidade**: FÃ¡cil de modificar e estender
5. **ReutilizaÃ§Ã£o**: Evitar duplicaÃ§Ã£o de cÃ³digo
6. **ConsistÃªncia**: Seguir padrÃµes estabelecidos
7. **Performance**: Considerar performance desde o inÃ­cio

## ğŸš« Anti-patterns a Evitar

- âŒ Classes com muitas responsabilidades
- âŒ DependÃªncias concretas em vez de abstraÃ§Ãµes
- âŒ LÃ³gica de negÃ³cio em controllers
- âŒ Queries N+1
- âŒ Hardcoded values
- âŒ CÃ³digo duplicado
- âŒ FunÃ§Ãµes muito longas (>20 linhas)
- âŒ Arquivos muito grandes (>300 linhas)

## ğŸ“ AtualizaÃ§Ã£o do Project Status

### Regras para AtualizaÃ§Ã£o do PROJECT_STATUS.md:
- **A cada commit significativo:** Atualizar a seÃ§Ã£o "HistÃ³rico de Commits"
- **Ao completar tarefas:** Marcar checkboxes no checklist
- **Ao encontrar problemas:** Documentar na seÃ§Ã£o "Problemas Conhecidos"
- **Ao tomar decisÃµes importantes:** Registrar em "DecisÃµes TÃ©cnicas"

### Formato do HistÃ³rico de Commits:
```markdown
### Commit: [hash do commit]
**Data:** [data do commit]
**Tipo:** [feat/fix/docs/style/refactor/test/chore]
**DescriÃ§Ã£o:** [DescriÃ§Ã£o do commit]

#### AlteraÃ§Ãµes Realizadas:
- [ ] [Lista detalhada de alteraÃ§Ãµes]

#### Arquivos Modificados:
- [ ] [Lista de arquivos criados/modificados]

#### PrÃ³ximos Passos:
- [ ] [PrÃ³ximas tarefas a serem realizadas]
```

## ğŸ”§ ConfiguraÃ§Ã£o Inicial do Projeto

### Regras para ConfiguraÃ§Ã£o Inicial:
- **Git Setup:** Sempre configurar Git antes de qualquer implementaÃ§Ã£o
- **DocumentaÃ§Ã£o:** Criar SETUP.md com instruÃ§Ãµes de configuraÃ§Ã£o
- **Ambiente:** Configurar variÃ¡veis de ambiente antes do desenvolvimento
- **DependÃªncias:** Instalar dependÃªncias base antes de criar aplicaÃ§Ãµes

### SequÃªncia de ConfiguraÃ§Ã£o Inicial:
1. **Git Repository Setup**
   - Inicializar repositÃ³rio Git
   - Conectar ao repositÃ³rio remoto
   - Fazer commit inicial com documentaÃ§Ã£o
   - Configurar branch main

2. **DocumentaÃ§Ã£o de Setup**
   - Criar SETUP.md com instruÃ§Ãµes completas
   - Documentar configuraÃ§Ã£o de ambiente
   - Incluir comandos de setup
   - Adicionar troubleshooting

3. **ConfiguraÃ§Ã£o de Ambiente**
   - Configurar variÃ¡veis de ambiente
   - Instalar dependÃªncias base
   - Configurar ferramentas de desenvolvimento
   - Validar configuraÃ§Ãµes

4. **AtualizaÃ§Ã£o de Status**
   - Atualizar PROJECT_STATUS.md
   - Documentar configuraÃ§Ãµes realizadas
   - Registrar decisÃµes tÃ©cnicas
   - Preparar prÃ³ximos passos 

## ğŸ“¦ Git Ignore

- Sempre manter um arquivo `.gitignore` atualizado na raiz do projeto.
- O `.gitignore` deve cobrir:
  - node_modules, dist, build, .nx, .env, .env.*, !.env.example
  - pastas de build de apps/libs
  - arquivos temporÃ¡rios de IDEs (VSCode, .idea, etc)
  - arquivos de sistema (Thumbs.db, .DS_Store)
  - arquivos de log, coverage, arquivos de teste temporÃ¡rios
  - arquivos binÃ¡rios e temporÃ¡rios do Windows/Mac
- Nunca versionar arquivos de ambiente sensÃ­veis (.env, local.env, etc)
- Sempre revisar o `.gitignore` ao adicionar novas ferramentas ou estruturas ao monorepo. 

## ğŸ“‘ AtualizaÃ§Ã£o de DocumentaÃ§Ã£o

- Sempre atualizar o PROJECT_STATUS.md e demais documentos relevantes (README.md, SETUP.md, SCOPE.md, etc) antes de realizar o push para o repositÃ³rio remoto. 

## ğŸš¦ ValidaÃ§Ã£o antes de Commit

- Sempre rodar a aplicaÃ§Ã£o (ou testes mÃ­nimos) para validar se estÃ¡ funcionando antes de realizar commits.
- A validaÃ§Ã£o deve ser feita APENAS antes do commit, nÃ£o antes de git add ou outras operaÃ§Ãµes.
- Se a aplicaÃ§Ã£o nÃ£o estiver funcionando, nÃ£o realizar o commit atÃ© que o problema seja resolvido. 